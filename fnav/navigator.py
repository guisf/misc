# -*- coding: utf-8 -*-

import curses
import sys
import os
import re
import commands

from files import FileManager

from curses import COLOR_BLACK as BLACK
from curses import COLOR_GREEN as GREEN
from curses import COLOR_YELLOW as YELLOW 
from curses import COLOR_WHITE as WHITE 
from curses import COLOR_RED as RED
from curses import COLOR_MAGENTA as MAGENTA
from curses import COLOR_CYAN as CYAN
from curses import COLOR_BLUE as BLUE
from curses import A_BOLD as BOLD
from curses import A_REVERSE as REVERSE
from curses import A_DIM as DIM
from curses import A_UNDERLINE as UNDERLINE
from curses import A_BLINK as BLINK
from curses import KEY_DOWN
from curses import KEY_UP
from curses import KEY_RIGHT
from curses import KEY_LEFT
from curses import KEY_RESIZE
KEY_ESC = 27
KEY_ENTER = 10

# Number of lines in the bottom.
BLINES = 2

# The keys are the file type and the values should be substrings
# of the output generated by the `file` command. The program matches substrings
# against the output of `file` to determine the file type.
# The values can be a single string or a list of strings, in this last case
# when the first substring is found the filetype is determined.
FILES = {
    'pdf':  'pdf',
    'py':   'python',
    'txt':  ['utf-8', 'ascii'],
    'chm':  'ms windows htmlhelp data',
    'djvu': 'djvu',
    'jpeg': 'jpeg',
    'png':  'png',
    'gif':  'gif',
    'ps':   'postscript',
    'pl':   'perl',
    'mp3':  'mp3',
    'avi':  ['avi', 'video'],
    'wmv':  'microsoft asf',
}

# Specify what programs should be used to open specific file types.
# The keys must be the same extensions as those in the FILES dict.
PROGS = {
    'pdf':  'xpdf',
    'py':   'xterm -e vi',
    'txt':  'xterm -e vi',
    'chm':  'xchm',
    'djvu': 'djview',
    'jpeg': 'gthumb',
    'png':  'gthumb',
    'gif':  'gthumb',
    'ps':   'evince',
    'pl':   'xterm -e vi',
    'mp3':  'xterm -e mpg123',
    'avi':  'vlc',
    'wmv':  'vlc',
}

# Specify some colors for the application appearance.
# The colors used for directories, files, executables, ... will be determined
# from your default `ls` command ($LS_COLORS variable).
# The format is (FOREGROUND, BACKGROUND, ATTRIBUTE).
COLORS = {
    'cwd':      (MAGENTA, 0, 0),
    'bracket':  (CYAN, 0, 0),
    'total':    (MAGENTA, 0, 0),
    'num':      (GREEN, 0, 0),
    'info':     (WHITE, 0, 0),
    'empty':    (RED, 0, 0),
    'open_err': (RED, 0, BOLD),
}


def _debug(*args):
    open('debug', 'a').write('\n'.join([str(x) for x in args]))

def colors():
    """Translate the colors in $LS_COLORS to curses attributes.
    Returns a dict.
    
    """
    foreground = {30: BLACK, 31: RED, 32: GREEN, 33: YELLOW, 34: BLUE, 
                  35: MAGENTA, 36: CYAN, 37: BLACK}
    background = {40: BLACK, 41: RED, 42: GREEN, 43: YELLOW, 44: BLUE, 
                  45: MAGENTA, 46: CYAN, 47: BLACK}
    attributes = {0: 0, 1: BOLD, 4: UNDERLINE, 5: BLINK, 7: REVERSE, 8: DIM}
    lscolors = commands.getoutput('echo $LS_COLORS')
    colors, defined, i = {}, {}, 1
    for item in lscolors.split(':'):
        if not item: 
            continue
        type, format = item.split('=')
        fg, bg, attr, text = 0, 0, 0, ''
        for item in format.split(';'):
            code = int(item)
            if  code in foreground:
                fg = foreground[code]
                text = "%s%i" % (text, code)
            elif code in background:
                bg = background[code]
                text = "%s%i" % (text, code)
            elif code in attributes:
                attr = attributes[code]
        if fg or bg:
            if text not in defined:
                curses.init_pair(i, fg, bg)
                colors[type] = curses.color_pair(i) | attr
                defined[text] = i
                i += 1
            else:
                colors[type] = curses.color_pair(defined[text]) | attr
        else:
            colors[type] = attr
    for key, color in COLORS.items():
        i += 1
        curses.init_pair(i, color[0], color[1])
        colors[key] = curses.color_pair(i) | color[2]
    return colors

def filetype(path):
    """Try to figure out what is the file type based on the output of
    the `file` command.
    
    """
    out = commands.getoutput('file "%s"' % path)
    out = out.replace('%s: ' % path, '')
    out = out.lower()
    for ext, element in FILES.items():
        if isinstance(element, list):
            find = 0
            for item in element:
                if item in out:
                    find = 1
                    break
            if find:
                break
        elif isinstance(element, str):
            if element in out:
                break
    else:
        name, ext = os.path.splitext(path)
        if ext in PROGS:
            return ext
        else:
            return False
    return ext


class Navigator:
    """Navigator interface.
    
    This class is the curses interface that will take actions bases on key
    presses and call functions of files.FileManager class.
    
    """

    def __init__(self, win, dir):
        self.win = win
        self.color = colors()
        self.rows, self.cols = self.win.getmaxyx()
        self.top = curses.newwin(1, self.cols)
        self.fm = FileManager(dir)
        self.y = 0 # current cursor position
        self.j = 0 # previous cursor position
        self.wcontents()

    def wline(self, y=None):
        if y == None:
            y = self.y
        item = self.fm.contents[y]
        ext = item.ext
        key = '*.%s' % ext
        if ext and (key in self.color):
            attr = self.color[key]
        else:
            attr = self.color.get(item.lstype(), 0)
        num = "%s " % str(y+1).rjust(self.length)
        self.pad.addnstr(y, 0, num, self.cols-1, self.color.get('num', 0))
        if 'l' in self.fm.option:
            info, name = item.repr()
            size = self.cols-1-self.length-1
            self.pad.addnstr(info, size, self.color.get('info', 0))
            try: 
                self.pad.addstr(' ', 0)
            except: 
                pass
            size -= len(info)+1
            if size > 0:
                self.pad.attron(attr)
                self.pad.addnstr(name, size)
                self.pad.attroff(attr)
        else:
            self.pad.attron(attr)
            self.pad.addnstr(item.name, self.cols-1-self.length-1)
            self.pad.attroff(attr)

    def wcontents(self, y=None):
        if y == None:
            y = self.y
        self.win.erase()
        self.win.refresh()
        self.fm.setcontents()
        self.lines = len(self.fm.contents)
        self.length = len("%i" % self.lines)
        if self.lines: # writing contents in the pad
            self.pad = curses.newpad(self.lines+BLINES, self.cols)
            for j in range(self.lines):
                self.wline(j)
            for i in range(BLINES):
                self.pad.addstr('\n')
            self.cursor(y, True)
            self.pad.noutrefresh(y, 0, 1, 0, self.rows-2, self.cols-1)
        else:
            self.pad = curses.newpad(1, self.cols)
            self.pad.addnstr('empty', self.cols-1, self.color.get('empty', 0))
            self.pad.noutrefresh(0, 0, 1, 0, 2, 0)
        self.pad.keypad(1)
        try: # writing contents in the header
            bracket = self.color.get('bracket')
            self.top.move(0,0)
            self.top.addstr('[', bracket)
            self.top.addstr(self.fm.cwd, self.color.get('cwd', 0))
            self.top.addstr(']', bracket)
            if self.lines > self.rows-2:
                self.top.addstr('[', bracket)
                self.top.addstr("%i items" % self.lines, 
                                    self.color.get('total', 0))
                self.top.addstr(']', bracket)
            if self.fm.regex:
                self.top.addstr('[', bracket)
                self.top.addstr(self.fm.regex)
                self.top.addstr(']', bracket)
            if self.fm.option:
                self.top.addstr('[', bracket)
                self.top.addstr(self.fm.option)
                self.top.addstr(']', bracket)
        except:
            pass
        self.top.noutrefresh()
        curses.doupdate()
        
    def cursor(self, y=None, on=True):
        """Enable or disable cursor under y position."""
        if y == None:
            y = self.y
        self.pad.move(y, 0)
        self.pad.clrtoeol()
        if on:
            self.pad.attron(REVERSE)
            self.wline(y)
            self.pad.attroff(REVERSE)
        else:
            self.wline(y)
    
    def run(self):
        """Program event loop."""
        while True:
            if self.y != self.j:
                self.cursor(self.j, False)
                self.cursor(self.y, True)
            begin = max(self.y-(self.rows-2-BLINES), 0)
            self.pad.refresh(begin, 0, 1, 0, self.rows-2, self.cols-1)
            self.j = self.y
            c = self.pad.getch()
            if c in (KEY_UP, ord('k')) and self.y > 0:
                self.y -= 1
            elif c in (KEY_DOWN, ord('j')) and self.y < self.lines-1:
                self.y += 1
            elif c in (KEY_RIGHT, ord('l'), KEY_ENTER):
                path = self.fm.contents[self.y]
                if path.type() == 'd':
                    self.fm.cwd = os.path.join(self.fm.cwd, path.name)
                    self.y = self.j = 0
                    self.wcontents()
                else:
                    file = os.path.join(self.fm.cwd, path.name)
                    type = filetype(file)
                    if type:
                        prog = PROGS.get(type, False)
                    else:
                        name, ext = os.path.splitext(path.name)
                        prog = PROGS.get(ext, False)
                    if prog:
                        cmd = '%s "%s" &>/dev/null &' % (prog, file)
                        os.system(cmd)
                    else:
                        text = 'No program specified to open it.'
                        attr = self.color.get('open_err', 0)
                        self.win.addnstr(self.rows-1,0,text,self.cols-1,attr)
                        self.win.refresh()
                        self.win.getch()
                        self.win.deleteln()
                        self.win.refresh()
            elif c in (KEY_LEFT, ord('h')) and self.fm.cwd != '/':
                self.fm.cwd, last_dir = os.path.split(self.fm.cwd)
                self.y = self.j = 0
                self.wcontents()
                self.y = self.fm.names.index(last_dir)
            elif c == ord('q'):
                break
            elif c == KEY_RESIZE:
                self.rows, self.cols = self.win.getmaxyx()
                self.top = curses.newwin(1, self.cols)
                self.wcontents()
            elif c == KEY_ESC:
                self.win.move(self.rows-1, 0)
                ch = self.win.getch()
                if ch == ord(':'):
                    self.win.addstr(':')
                    curses.curs_set(1)
                    curses.echo()
                    input = self.win.getstr()
                    self.command_line(input)
                    curses.noecho()
                    curses.curs_set(0)
                elif ch == KEY_ESC:
                    pass
                elif ch == ord('h'):
                    self.fm.cwd = os.path.expanduser('~')
                    y = j = 0
                self.wcontents(y)

    def command_line(self, input):
        """Do something based on user input."""
        input = input.strip()
        if re.match(r'set\s+noption', input):
            self.fm.option = ''
            self.wcontents()
        elif input.startswith('set'):
            a = re.match(r'set\s+(\w+)\s+(\w+)', input)
            if a:
                var, value = a.groups()
                if var == 'option':
                    self.fm.option = value
                elif var == 'regex':
                    self.fm.regex = r'%s' % value
                self.wcontents()
                
