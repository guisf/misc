#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""File navigator with curses interface."""

import curses
import sys
import os
import re
import commands

from files import FileManager

from curses import COLOR_BLACK as BLACK
from curses import COLOR_GREEN as GREEN
from curses import COLOR_YELLOW as YELLOW 
from curses import COLOR_WHITE as WHITE 
from curses import COLOR_RED as RED
from curses import COLOR_MAGENTA as MAGENTA
from curses import COLOR_CYAN as CYAN
from curses import COLOR_BLUE as BLUE
from curses import A_BOLD as BOLD
from curses import A_REVERSE as REVERSE
from curses import A_DIM as DIM
from curses import A_UNDERLINE as UNDERLINE
from curses import A_BLINK as BLINK

from curses import KEY_DOWN
from curses import KEY_UP
from curses import KEY_RIGHT
from curses import KEY_LEFT
from curses import KEY_RESIZE
KEY_ESC = 27
KEY_ENTER = 10

# The keys are the file type and the values should be substrings
# of the output generated by the `file` command. The program matches substring
# against the output of `file` to determine the file type.
FILES = {
    'pdf': 'pdf',
    'py': 'python',
    'txt': ['utf-8', 'ascii'],
    'chm': 'ms windows htmlhelp data',
    'djvu': 'djvu',
    'jpeg': 'jpeg',
    'png': 'png',
    'gif': 'gif',
    'ps': 'postscript',
    'pl': 'perl',
    'mp3': 'mp3',
}

# Specify what program should be used to open specific file types.
PROGS = {
    'pdf': 'xpdf',
    'py': 'xterm -e vi',
    'txt': 'xterm -e vi',
    'chm': 'xchm',
    'djvu': 'djview',
    'jpeg': 'gthumb',
    'png': 'gthumb',
    'gif': 'gthum',
    'ps': 'evince',
    'pl': 'xterm -e vi',
    'mp3': 'xterm -e mpg123',
}

# Specify some colors for application appearance.
COLORS = {
    'cwd': (WHITE, 0, BOLD),
    'bracket': (CYAN, 0, 0),
    'total': (WHITE, 0, 0),
    'num': (BLACK, 0, BOLD),
    'info': (RED, 0, 0),
    'empty': (RED, 0, 0),
}

def debug(*args):
    """Just write something to a text file."""
    open('debug', 'a').write('\n'.join([str(x) for x in args]))

def colors():
    """Translate the colors in $LS_COLORS to curses attributes."""
    global COLORS
    foreground = {30: BLACK, 31: RED, 32: GREEN, 33: YELLOW, 34: BLUE, 
                    35: MAGENTA, 36: CYAN, 37: BLACK}
    background = {40: BLACK, 41: RED, 42: GREEN, 43: YELLOW, 44: BLUE, 
                    45: MAGENTA, 46: CYAN, 47: BLACK}
    attributes = {0: 0, 1: BOLD, 4: UNDERLINE, 5: BLINK, 7: REVERSE, 8: DIM}
    lscolors = commands.getoutput('echo $LS_COLORS')
    colors, defined, i = {}, {}, 1
    for item in lscolors.split(':'):
        if not item: continue
        type, format = item.split('=')
        fg, bg, attr, text = 0, 0, 0, ''
        for item in format.split(';'):
            code = int(item)
            if  code in foreground:
                fg = foreground[code]
                text = "%s%i" % (text, code)
            elif code in background:
                bg = background[code]
                text = "%s%i" % (text, code)
            elif code in attributes:
                attr = attributes[code]
        if fg or bg:
            if text not in defined:
                curses.init_pair(i, fg, bg)
                colors[type] = curses.color_pair(i) | attr
                defined[text] = i
                i += 1
            else:
                colors[type] = curses.color_pair(defined[text]) | attr
        else:
            colors[type] = attr
    for key, (fg, bg, attr) in COLORS:
        i += 1
        curses.init_pair(i, fg, bg)
        colors[key] = curses.color_pair(i) | attr
    return colors

def filetype(path):
    """Try to figure out what is the file type based on the output of
    the `file` command."""
    global FILES, PROGS
    out = commands.getoutput('file "%s"' % path)
    out = re.sub(r'.+: ', '', out)
    out = out.lower()
    for ext, element in FILES.items():
        if isinstance(element, list):
            find = 0
            for item in element:
                if item in out:
                    find = 1
                    break
            if find:
                break
        elif isinstance(element, str):
            if element in out:
                break
    else:
        name, ext = os.path.splitext(path)
        if ext in PROGS:
            return ext
        else:
            return False
    return ext


class Navigator(FileManager):
    """The curses interface is builded uppon FileManager."""

    def __init__(self, win, dir):
        """win:  stdscr, dir: directory to be opened."""
        self.win = win
        self.dir = dir
        self.color = colors()
        self.rows, self.cols = self.win.getmaxyx()
        self.top = curses.newwin(1, self.cols)
        self.wcontents() # write dir contents in the screen

    def wline(self, y):
        """For each element in self.contents, write it as a line in the
        screen."""
        item = self.contents[y]
        ext = item.ext
        key = '*.%s' % ext # LS_COLOR format for file extension
        if ext and (key in self.color):
            attr = self.color[key]
        else: # get color depending o path type: dir, regular file, fifo, ...
            attr = self.color.get(item.lstype(), 0)
        num = "%s " % str(y+1).rjust(self.length)
        self.pad.addstr(y, 0, num, self.color.get('num', 0)) # line number
        if 'l' in self.option:
            info, name = item.repr()
            size = len(info)+self.length+1
            self.pad.addnstr(info, self.cols-1-self.length-1,
                                self.color.get('info', 0))
            if size < self.cols-2:
                self.pad.addstr(' ', 0)
            space = max(self.cols-2-size, 0)
            if space:
                self.pad.attron(attr)
                self.pad.addnstr(name, space)
                self.pad.attroff(attr)
        else:
            self.pad.attron(attr)
            self.pad.addnstr(item.name, self.cols-1-self.length-1)
            self.pad.attroff(attr)

    def wcontents(self, y=0):
        """Write contents inside self.dir in the screen."""
        self.win.clear()
        self.top.clear()
        self.win.refresh()
        FileManager.__init__(self, self.dir)
        # write contents
        self.lines = len(self.contents)
        self.length = len("%i" % self.lines)
        if self.lines:
            self.pad = curses.newpad(self.lines, self.cols)
            for j in range(self.lines):
                self.wline(j)
            self.cursor(y, True)
            self.pad.noutrefresh(y, 0, 1, 0, self.rows-1, self.cols-1)
        else:
            self.pad = curses.newpad(self.rows, self.cols)
            self.pad.addnstr('empty', self.cols-1, self.color.get('empty', 0))
            self.pad.noutrefresh(0, 0, 1, 0, self.rows-1, self.cols-1)
        self.pad.keypad(1)
        # write top header
        try:
            self.top.addstr('[', self.color.get('bracket', 0))
            self.top.addstr(self.cwd, self.color.get('top', 0))
            self.top.addstr(']', self.color.get('bracket', 0))
            if self.lines > self.rows:
                self.top.addstr(' ')
                self.top.addstr("%i items" % self.lines, 
                                    self.color.get('total', 0))
        except:
            pass
        self.top.noutrefresh()
        curses.doupdate()
        
    def cursor(self, y, on=True):
        """Enable or diseable cursor under y position."""
        self.pad.move(y, 0)
        self.pad.clrtoeol()
        if on:
            self.pad.attron(REVERSE)
            self.wline(y)
            self.pad.attroff(REVERSE)
        else:
            self.wline(y)
    
    def run(self):
        """Main event loop."""
        global PROGS
        y = j = 0 # y/j = current/previous position
        while True:
            if y != j:
                self.cursor(j, False)
                self.cursor(y, True)
            begin = max(y-(self.rows-2), 0)
            self.pad.refresh(begin, 0, 1, 0, self.rows-1, self.cols-1)
            j = y
            c = self.pad.getch()
            if c in (KEY_UP, ord('k')) and y > 0:
                y -= 1
            elif c in (KEY_DOWN, ord('j')) and y < self.lines-1:
                y += 1
            elif c in (KEY_RIGHT, ord('l'), KEY_ENTER):
                path = self.contents[y]
                if path.type() == 'd':
                    self.dir = os.path.join(self.dir, path.name)
                    self.wcontents()
                    y = j = 0
                else:
                    file = os.path.join(self.cwd, path.name)
                    type = filetype(file)
                    if type:
                        prog = PROGS.get(type, False)
                    else:
                        name, ext = os.path.splitext(path.name)
                        prog = PROGS.get(ext, False)
                    if prog:
                        cmd = '%s "%s" &>/dev/null &' % (prog, file)
                        os.system(cmd)
            elif c in (KEY_LEFT, ord('h')) and self.cwd != '/':
                self.dir = os.path.dirname(self.cwd)
                self.wcontents()
                y = j = 0
            elif c == ord('q'):
                break
            elif c == KEY_RESIZE:
                self.rows, self.cols = self.win.getmaxyx()
                self.top = curses.newwin(1, self.cols)
                self.wcontents(y)
                
